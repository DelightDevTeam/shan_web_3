<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>GoldenMM - Modern Gaming Experience</title>
    <link rel="shortcut icon" href="TemplateData/favicon.ico">
    <link rel="stylesheet" href="TemplateData/style.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  </head>
  <body>
    <!-- Modern Loading Screen -->
    <div id="modern-loading-screen" class="loading-screen">
      <div class="loading-content">
        <div class="game-logo">
          <i class="fas fa-gamepad"></i>
          <h1>GoldenMM</h1>
        </div>
        <div class="loading-animation">
          <div class="spinner"></div>
        </div>
        <div class="loading-text">
          <p>Loading your adventure...</p>
          <div class="progress-container">
            <div class="progress-bar">
              <div class="progress-fill" id="modern-progress-fill"></div>
            </div>
            <span class="progress-text" id="modern-progress-text">0%</span>
          </div>
        </div>
        <div class="loading-tips">
          <p><i class="fas fa-lightbulb"></i> Tip: Use WASD or arrow keys to move</p>
        </div>
      </div>
    </div>

    <!-- Device Orientation Message -->
    <div id="rotate-message" class="rotate-message">
      <div class="rotate-content">
        <i class="fas fa-mobile-alt fa-rotate-90"></i>
        <h3>Please Rotate Your Device</h3>
        <p>For the best gaming experience, please rotate to landscape mode</p>
      </div>
    </div>

    <!-- Main Game Container -->
    <div id="unity-container" class="unity-container">
      <canvas id="unity-canvas" width=960 height=600 tabindex="-1"></canvas>
      
      <!-- Game Controls Overlay -->
      <div class="game-controls">
        <button class="control-btn fullscreen-btn" id="fullscreen-btn" title="Toggle Fullscreen">
          <i class="fas fa-expand"></i>
        </button>
        <button class="control-btn settings-btn" id="settings-btn" title="Game Settings">
          <i class="fas fa-cog"></i>
        </button>
        <button class="control-btn help-btn" id="help-btn" title="Help & Controls">
          <i class="fas fa-question-circle"></i>
        </button>
      </div>

      <!-- Game Title Bar -->
      <div class="game-title-bar">
        <div class="game-info">
          <span class="game-title">GoldenMM</span>
          <span class="game-version">v1.0.3</span>
        </div>
        <div class="game-status">
          <span class="status-indicator" id="status-indicator">
            <i class="fas fa-circle"></i> Ready
          </span>
        </div>
      </div>

      <!-- Warning Banner -->
      <div id="unity-warning" class="warning-banner"></div>
    </div>

    <!-- Settings Modal -->
    <div id="settings-modal" class="modal">
      <div class="modal-content">
        <div class="modal-header">
          <h3><i class="fas fa-cog"></i> Game Settings</h3>
          <button class="close-btn" id="close-settings">
            <i class="fas fa-times"></i>
          </button>
        </div>
        <div class="modal-body">
          <div class="setting-group">
            <label>Graphics Quality</label>
            <select id="graphics-quality">
              <option value="low">Low</option>
              <option value="medium" selected>Medium</option>
              <option value="high">High</option>
            </select>
          </div>
          <div class="setting-group">
            <label>Sound Volume</label>
            <input type="range" id="sound-volume" min="0" max="100" value="80">
            <span class="volume-value">80%</span>
          </div>
          <div class="setting-group">
            <label>Music Volume</label>
            <input type="range" id="music-volume" min="0" max="100" value="60">
            <span class="volume-value">60%</span>
          </div>
        </div>
      </div>
    </div>

    <!-- Help Modal -->
    <div id="help-modal" class="modal">
      <div class="modal-content">
        <div class="modal-header">
          <h3><i class="fas fa-question-circle"></i> Help & Controls</h3>
          <button class="close-btn" id="close-help">
            <i class="fas fa-times"></i>
          </button>
        </div>
        <div class="modal-body">
          <div class="control-section">
            <h4>Keyboard Controls</h4>
            <div class="control-grid">
              <div class="control-item">
                <span class="key">WASD</span>
                <span class="action">Move</span>
              </div>
              <div class="control-item">
                <span class="key">Space</span>
                <span class="action">Jump</span>
              </div>
              <div class="control-item">
                <span class="key">E</span>
                <span class="action">Interact</span>
              </div>
              <div class="control-item">
                <span class="key">ESC</span>
                <span class="action">Pause</span>
              </div>
            </div>
          </div>
          <div class="control-section">
            <h4>Mouse Controls</h4>
            <div class="control-grid">
              <div class="control-item">
                <span class="key">Left Click</span>
                <span class="action">Select</span>
              </div>
              <div class="control-item">
                <span class="key">Right Click</span>
                <span class="action">Context Menu</span>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Notification System -->
    <div id="notification-container" class="notification-container">
      <button id="dismiss-all-notifications" class="dismiss-all-btn" title="Dismiss all notifications">
        <i class="fas fa-times"></i>
      </button>
    </div>

    <!-- Room Loading Overlay -->
    <div id="room-loading-overlay" class="room-loading-overlay">
      <div class="room-loading-content">
        <h3><i class="fas fa-door-open"></i> Loading Game Room</h3>
        <p id="room-loading-text">Preparing your gaming experience...</p>
        <div class="room-loading-progress">
          <div class="room-loading-progress-fill" id="room-progress-fill"></div>
        </div>
        <p id="room-loading-status">Initializing...</p>
      </div>
    </div>

    <script>
      // Modern UI State Management
      let gameInstance = null;
      let isLoading = true;
      let currentProgress = 0;
      let loadingTimeout = null;
      let isGameLoaded = false;
      let globalTimeoutProtection = null;

      // Performance monitoring
      let loadStartTime = Date.now();
      let lastProgressUpdate = 0;
      let performanceWarningsShown = new Set();
      
      // DOM Elements
      const loadingScreen = document.getElementById('modern-loading-screen');
      const progressFill = document.getElementById('modern-progress-fill');
      const progressText = document.getElementById('modern-progress-text');
      const statusIndicator = document.getElementById('status-indicator');
      const settingsModal = document.getElementById('settings-modal');
      const helpModal = document.getElementById('help-modal');
      const notificationContainer = document.getElementById('notification-container');

      // Performance optimization settings
      const PERFORMANCE_CONFIG = {
        maxLoadTime: 30000, // 30 seconds max loading time
        progressUpdateInterval: 100, // Update progress every 100ms
        memoryThreshold: 0.8, // 80% memory usage threshold
        timeoutWarning: 15000, // Show warning after 15 seconds
        retryAttempts: 3
      };

      // Game Room Loading System
      let isRoomLoading = false;
      let roomLoadTimeout = null;
      let currentRoomId = null;
      let retryCount = 0;
      let isRetrying = false;
      
      // Room loading configuration
      const ROOM_CONFIG = {
        maxLoadTime: 15000, // 15 seconds max for room loading
        progressInterval: 100, // Update progress every 100ms
        maxRetryAttempts: 2, // Maximum retry attempts
        fallbackDelay: 3000, // Wait 3 seconds before fallback
        retryCooldown: 5000 // Wait 5 seconds between retries
      };
      
      // Game room loading states
      const ROOM_STATES = {
        IDLE: 'idle',
        LOADING: 'loading',
        SUCCESS: 'success',
        ERROR: 'error',
        TIMEOUT: 'timeout',
        RETRYING: 'retrying',
        FAILED: 'failed'
      };
      
      let currentRoomState = ROOM_STATES.IDLE;
      
      // Initialize game room system
      function initializeGameRooms() {
        // Wait for Unity to be ready
        if (gameInstance) {
          setupRoomEventListeners();
        } else {
          // If Unity isn't ready yet, wait for it
          const checkUnity = setInterval(() => {
            if (gameInstance) {
              clearInterval(checkUnity);
              setupRoomEventListeners();
            }
          }, 100);
        }
      }
      
      // Setup room event listeners
      function setupRoomEventListeners() {
        // Listen for Unity room loading events
        if (gameInstance) {
          try {
            // Send message to Unity to setup room event listeners
            gameInstance.SendMessage('GameManager', 'SetupRoomEventListeners');
            
            // Listen for room loading progress from Unity
            gameInstance.on('roomProgress', (progress) => {
              updateRoomLoadingProgress(progress);
            });
            
            // Listen for room loading completion
            gameInstance.on('roomLoaded', (roomData) => {
              handleRoomLoaded(roomData);
            });
            
            // Listen for room loading errors
            gameInstance.on('roomError', (error) => {
              handleRoomError(error);
            });
            
          } catch (e) {
            console.warn('Unity room events not available, using fallback system');
            setupFallbackRoomSystem();
          }
        }
      }
      
      // Fallback room system for when Unity events aren't available
      function setupFallbackRoomSystem() {
        // Create room buttons dynamically if they don't exist
        const roomButtons = document.querySelectorAll('[data-room-id]');
        if (roomButtons.length === 0) {
          createFallbackRoomButtons();
        }
        
        // Add click event listeners
        roomButtons.forEach(button => {
          button.addEventListener('click', (e) => {
            e.preventDefault();
            const roomId = button.getAttribute('data-room-id');
            if (roomId && !isRoomLoading) {
              loadGameRoom(roomId);
            }
          });
        });
      }
      
      // Create fallback room buttons
      function createFallbackRoomButtons() {
        const roomContainer = document.querySelector('.game-rooms') || document.body;
        const roomIds = ['100', '300', '500', '800'];
        
        roomIds.forEach(roomId => {
          const button = document.createElement('button');
          button.className = 'room-button fallback-room-btn';
          button.setAttribute('data-room-id', roomId);
          button.innerHTML = `
            <span class="room-value">${roomId}</span>
            <div class="room-loading-indicator" style="display: none;">
              <div class="room-spinner"></div>
            </div>
          `;
          
          roomContainer.appendChild(button);
        });
      }
      
      // Load game room with comprehensive error handling
      function loadGameRoom(roomId) {
        if (isRoomLoading) {
          showNotification('Room already loading. Please wait...', 'warning', 3000);
          return;
        }
        
        // Prevent multiple room loads
        isRoomLoading = true;
        currentRoomId = roomId;
        currentRoomState = ROOM_STATES.LOADING;
        
        // Show room loading overlay
        showRoomLoadingOverlay(roomId);
        
        // Update UI to show loading state
        updateRoomLoadingUI(roomId, true);
        
        // Show room loading notification
        showNotification(`Loading room ${roomId}...`, 'info', 3000);
        
        // Start room loading timeout protection
        startRoomLoadTimeout();
        
        // Try to load room through Unity
        if (gameInstance) {
          try {
            // Send message to Unity to load room
            gameInstance.SendMessage('GameManager', 'LoadRoom', roomId);
            
            // Start progress simulation if Unity doesn't provide progress
            startRoomProgressSimulation();
            
          } catch (e) {
            console.warn('Unity room loading failed, using fallback:', e);
            handleRoomLoadFallback(roomId);
          }
        } else {
          // Unity not ready, use fallback
          handleRoomLoadFallback(roomId);
        }
      }
      
      // Show room loading overlay
      function showRoomLoadingOverlay(roomId) {
        const overlay = document.getElementById('room-loading-overlay');
        const loadingText = document.getElementById('room-loading-text');
        const loadingStatus = document.getElementById('room-loading-status');
        
        if (overlay && loadingText && loadingStatus) {
          loadingText.textContent = `Loading Room ${roomId}...`;
          loadingStatus.textContent = 'Initializing...';
          overlay.classList.add('show');
        }
      }
      
      // Hide room loading overlay
      function hideRoomLoadingOverlay() {
        const overlay = document.getElementById('room-loading-overlay');
        if (overlay) {
          overlay.classList.remove('show');
        }
      }
      
      // Update room loading overlay progress
      function updateRoomLoadingOverlay(progress, status) {
        const progressFill = document.getElementById('room-progress-fill');
        const loadingStatus = document.getElementById('room-loading-status');
        
        if (progressFill) {
          progressFill.style.width = `${progress * 100}%`;
        }
        
        if (loadingStatus && status) {
          loadingStatus.textContent = status;
        }
      }
      
      // Start room loading timeout protection
      function startRoomLoadTimeout() {
        roomLoadTimeout = setTimeout(() => {
          if (currentRoomState === ROOM_STATES.LOADING) {
            handleRoomTimeout();
          }
        }, ROOM_CONFIG.maxLoadTime);
      }
      
      // Handle room loading timeout
      function handleRoomTimeout() {
        currentRoomState = ROOM_STATES.TIMEOUT;
        isRoomLoading = false;
        
        // Hide loading overlay
        hideRoomLoadingOverlay();
        
        // Check if we've exceeded retry attempts
        if (retryCount >= ROOM_CONFIG.maxRetryAttempts) {
          // Max retries exceeded, show failure state
          currentRoomState = ROOM_STATES.FAILED;
          showNotification(`Room loading failed after ${ROOM_CONFIG.maxRetryAttempts} attempts. Please try again later.`, 'error', 8000);
          
          // Update UI to show failure
          updateRoomLoadingUI(currentRoomId, false);
          
          // Reset everything after delay
          setTimeout(() => {
            resetRoomState();
          }, 5000);
          
          return;
        }
        
        // Increment retry count
        retryCount++;
        
        showNotification(`Room loading timeout (attempt ${retryCount}/${ROOM_CONFIG.maxRetryAttempts}). Retrying...`, 'warning', 5000);
        
        // Update UI
        updateRoomLoadingUI(currentRoomId, false);
        
        // Wait for cooldown before retrying
        setTimeout(() => {
          if (!isRetrying && retryCount <= ROOM_CONFIG.maxRetryAttempts) {
            retryRoomLoad();
          }
        }, ROOM_CONFIG.retryCooldown);
      }
      
      // Retry room loading
      function retryRoomLoad() {
        if (isRetrying || retryCount > ROOM_CONFIG.maxRetryAttempts) {
          return;
        }
        
        isRetrying = true;
        currentRoomState = ROOM_STATES.RETRYING;
        
        showNotification(`Retrying room load (attempt ${retryCount}/${ROOM_CONFIG.maxRetryAttempts})...`, 'info', 4000);
        
        // Reset loading state and try again
        setTimeout(() => {
          if (currentRoomId) {
            loadGameRoom(currentRoomId);
          }
        }, 1000);
      }
      
      // Handle room loading fallback
      function handleRoomLoadFallback(roomId) {
        // Simulate room loading for fallback
        let progress = 0;
        const progressInterval = setInterval(() => {
          progress += Math.random() * 20;
          if (progress >= 100) {
            progress = 100;
            clearInterval(progressInterval);
            
            // Simulate successful room load
            setTimeout(() => {
              handleRoomLoaded({ roomId, success: true, fallback: true });
            }, 500);
          }
          
          updateRoomLoadingProgress(progress / 100);
        }, 200);
      }
      
      // Start room progress simulation
      function startRoomProgressSimulation() {
        let progress = 0;
        const progressInterval = setInterval(() => {
          if (currentRoomState !== ROOM_STATES.LOADING) {
            clearInterval(progressInterval);
            return;
          }
          
          progress += Math.random() * 15;
          if (progress >= 90) {
            progress = 90; // Don't complete, wait for Unity
            clearInterval(progressInterval);
          }
          
          updateRoomLoadingProgress(progress / 100);
        }, ROOM_CONFIG.progressInterval);
      }
      
      // Update room loading progress
      function updateRoomLoadingProgress(progress) {
        if (currentRoomState !== ROOM_STATES.LOADING) return;
        
        // Update overlay progress
        updateRoomLoadingOverlay(progress, getProgressStatus(progress));
        
        // Update progress bar if it exists
        const progressBar = document.querySelector('.room-progress-bar');
        if (progressBar) {
          progressBar.style.width = `${progress * 100}%`;
        }
        
        // Update room button loading state
        updateRoomButtonProgress(currentRoomId, progress);
      }
      
      // Get progress status text
      function getProgressStatus(progress) {
        if (progress < 0.2) return 'Initializing...';
        if (progress < 0.4) return 'Loading assets...';
        if (progress < 0.6) return 'Preparing game environment...';
        if (progress < 0.8) return 'Finalizing setup...';
        if (progress < 1.0) return 'Almost ready...';
        return 'Ready!';
      }
      
      // Update room button progress
      function updateRoomButtonProgress(roomId, progress) {
        const button = document.querySelector(`[data-room-id="${roomId}"]`);
        if (button) {
          const indicator = button.querySelector('.room-loading-indicator');
          if (indicator) {
            indicator.style.display = 'block';
            
            // Update spinner animation based on progress
            const spinner = indicator.querySelector('.room-spinner');
            if (spinner) {
              spinner.style.animationDuration = `${1 - progress * 0.5}s`;
            }
          }
        }
      }
      
      // Handle successful room load
      function handleRoomLoaded(roomData) {
        clearTimeout(roomLoadTimeout);
        currentRoomState = ROOM_STATES.SUCCESS;
        isRoomLoading = false;
        
        // Hide loading overlay
        hideRoomLoadingOverlay();
        
        // Update UI to show loading state
        updateRoomLoadingUI(currentRoomId, false);
        
        if (roomData.fallback) {
          showNotification(`Room ${roomData.roomId} loaded (fallback mode)`, 'success', 3000);
        } else {
          showNotification(`Room ${roomData.roomId} loaded successfully!`, 'success', 3000);
        }
        
        // Reset state after delay
        setTimeout(() => {
          resetRoomState();
        }, 2000);
      }
      
      // Handle room loading error
      function handleRoomError(error) {
        clearTimeout(roomLoadTimeout);
        currentRoomState = ROOM_STATES.ERROR;
        isRoomLoading = false;
        
        // Hide loading overlay
        hideRoomLoadingOverlay();
        
        // Update UI to show loading state
        updateRoomLoadingUI(currentRoomId, false);
        
        showNotification(`Room loading failed: ${error}`, 'error', 5000);
        
        // Reset state after delay
        setTimeout(() => {
          resetRoomState();
        }, 2000);
      }
      
      // Update room loading UI
      function updateRoomLoadingUI(roomId, isLoading) {
        const button = document.querySelector(`[data-room-id="${roomId}"]`);
        if (button) {
          if (isLoading) {
            button.classList.add('loading');
            button.disabled = true;
          } else {
            button.classList.remove('loading');
            button.disabled = false;
            
            // Hide loading indicator
            const indicator = button.querySelector('.room-loading-indicator');
            if (indicator) {
              indicator.style.display = 'none';
            }
          }
        }
      }
      
      // Reset room state
      function resetRoomState() {
        currentRoomState = ROOM_STATES.IDLE;
        currentRoomId = null;
        isRoomLoading = false;
        
        // Clear any remaining timeouts
        if (roomLoadTimeout) {
          clearTimeout(roomLoadTimeout);
          roomLoadTimeout = null;
        }
        
        // Reset all room buttons
        const roomButtons = document.querySelectorAll('[data-room-id]');
        roomButtons.forEach(button => {
          button.classList.remove('loading');
          button.disabled = false;
          
          const indicator = button.querySelector('.room-loading-indicator');
          if (indicator) {
            indicator.style.display = 'none';
          }
        });
      }

      // Device Orientation Check
      function checkOrientation() {
        const rotateMessage = document.getElementById("rotate-message");
        if (window.innerHeight > window.innerWidth && window.innerWidth < 768) {
          rotateMessage.style.display = "flex";
        } else {
          rotateMessage.style.display = "none";
        }
      }

      // Event Listeners
      window.addEventListener("resize", checkOrientation);
      window.addEventListener("orientationchange", checkOrientation);
      checkOrientation();

      // Performance monitoring
      function checkPerformance() {
        const currentTime = Date.now();
        const loadTime = currentTime - loadStartTime;
        
        // Show warning if loading takes too long (only once)
        if (loadTime > PERFORMANCE_CONFIG.timeoutWarning && !isGameLoaded && !performanceWarningsShown.has('slow')) {
          performanceWarningsShown.add('slow');
          showNotification('Game is taking longer than usual to load. Please wait...', 'warning', 5000);
        }
        
        // Remove aggressive timeout - let Unity handle its own loading
        // This prevents constant timeout messages and refresh buttons
      }

      // Handle loading issues gracefully without aggressive timeouts
      function handleLoadingIssue() {
        // Only show this if we're actually stuck, not just slow
        if (isLoading === false) {
          return;
        }
        
        // Show a gentle message instead of aggressive timeout
        showNotification('Game loading is taking longer than expected. Please be patient.', 'info', 8000);
        
        // Don't change status or add refresh button - just inform user
        // This creates a better user experience
      }
      
      // Remove manual refresh button - not needed with new approach
      // Users can use browser refresh if they really need to

      // Memory monitoring
      function checkMemoryUsage() {
        if ('memory' in performance) {
          const memoryInfo = performance.memory;
          const usagePercent = memoryInfo.usedJSHeapSize / memoryInfo.jsHeapSizeLimit;
          
          if (usagePercent > PERFORMANCE_CONFIG.memoryThreshold) {
            showNotification('High memory usage detected. Consider refreshing the page.', 'warning', 5000);
          }
        }
      }

      // Optimized progress update
      function updateProgress(progress) {
        const currentTime = Date.now();
        
        // Throttle progress updates for better performance
        if (currentTime - lastProgressUpdate < PERFORMANCE_CONFIG.progressUpdateInterval) {
          return;
        }
        
        currentProgress = progress;
        lastProgressUpdate = currentTime;
        
        if (progressFill && progressText) {
          progressFill.style.width = (100 * progress) + "%";
          progressText.textContent = Math.round(100 * progress) + "%";
        }
        
        // Check performance periodically
        checkPerformance();
        
        if (progress >= 1) {
          handleGameLoaded();
        }
      }

      // Handle successful game load
      function handleGameLoaded() {
        isGameLoaded = true;
        isLoading = false;
        
        setTimeout(() => {
          if (loadingScreen) {
            loadingScreen.classList.add('fade-out');
            setTimeout(() => {
              loadingScreen.style.display = 'none';
              statusIndicator.innerHTML = '<i class="fas fa-circle"></i> Playing';
              statusIndicator.className = 'status-indicator playing';
              showNotification('Game loaded successfully!', 'success');
              
              // Start performance monitoring
              setInterval(checkMemoryUsage, 10000); // Check every 10 seconds
            }, 500);
          }
        }, 500);
      }

      // Modal Management
      function showModal(modal) {
        modal.style.display = "flex";
        document.body.style.overflow = "hidden";
      }

      function hideModal(modal) {
        modal.style.display = "none";
        document.body.style.overflow = "auto";
      }

      // Settings Modal
      document.getElementById('settings-btn').addEventListener('click', () => {
        showModal(settingsModal);
      });

      document.getElementById('close-settings').addEventListener('click', () => {
        hideModal(settingsModal);
      });

      // Help Modal
      document.getElementById('help-btn').addEventListener('click', () => {
        showModal(helpModal);
      });

      document.getElementById('close-help').addEventListener('click', () => {
        hideModal(helpModal);
      });

      // Volume Controls
      document.getElementById('sound-volume').addEventListener('input', (e) => {
        const value = e.target.value;
        e.target.nextElementSibling.textContent = value + '%';
        // Here you can add Unity audio control logic
      });

      document.getElementById('music-volume').addEventListener('input', (e) => {
        const value = e.target.value;
        e.target.nextElementSibling.textContent = value + '%';
        // Here you can add Unity audio control logic
      });

      // Enhanced Notification System
      let activeNotifications = new Set();
      const MAX_NOTIFICATIONS = 3; // Maximum number of notifications to show at once
      
      function showNotification(message, type = 'info', duration = 3000) {
        // Check if this exact message is already showing
        if (activeNotifications.has(message)) {
          return; // Don't show duplicate notifications
        }
        
        // Limit the number of notifications
        if (activeNotifications.size >= MAX_NOTIFICATIONS) {
          // Remove oldest notification
          const oldestNotification = notificationContainer.firstChild;
          if (oldestNotification) {
            oldestNotification.remove();
            activeNotifications.delete(oldestNotification.textContent || '');
          }
        }
        
        const notification = document.createElement('div');
        notification.className = `notification notification-${type}`;
        notification.innerHTML = `
          <i class="fas fa-${type === 'success' ? 'check-circle' : type === 'error' ? 'exclamation-circle' : type === 'warning' ? 'exclamation-triangle' : 'info-circle'}"></i>
          <span>${message}</span>
        `;
        
        notificationContainer.appendChild(notification);
        activeNotifications.add(message);
        
        setTimeout(() => {
          notification.classList.add('show');
        }, 100);
        
        setTimeout(() => {
          notification.classList.remove('show');
          setTimeout(() => {
            notification.remove();
            activeNotifications.delete(message);
          }, 300);
        }, duration);
      }

      // Dismiss all notifications
      function dismissAllNotifications() {
        const notifications = notificationContainer.querySelectorAll('.notification');
        notifications.forEach(notification => {
          notification.classList.remove('show');
          setTimeout(() => {
            notification.remove();
          }, 300);
        });
        activeNotifications.clear();
      }
      
      // Add event listener for dismiss all button
      document.addEventListener('DOMContentLoaded', () => {
        const dismissAllBtn = document.getElementById('dismiss-all-notifications');
        if (dismissAllBtn) {
          dismissAllBtn.addEventListener('click', dismissAllNotifications);
        }
      });

      // Unity Integration with Performance Optimizations
      var container = document.querySelector("#unity-container");
      var canvas = document.querySelector("#unity-canvas");
      var fullscreenButton = document.getElementById("fullscreen-btn");
      var warningBanner = document.querySelector("#unity-warning");

      // Enhanced Unity banner system
      function unityShowBanner(msg, type) {
        function updateBannerVisibility() {
          warningBanner.style.display = warningBanner.children.length ? 'block' : 'none';
        }
        var div = document.createElement('div');
        div.innerHTML = msg;
        warningBanner.appendChild(div);
        
        if (type == 'error') {
          div.className = 'warning-item error';
          showNotification(msg, 'error', 5000);
          
          // Handle Unity errors gracefully
          if (msg.includes('room') || msg.includes('connection')) {
            showNotification('Connection issue detected. Please check your internet and try again.', 'warning', 8000);
          }
        } else if (type == 'warning') {
          div.className = 'warning-item warning';
          showNotification(msg, 'warning', 3000);
        } else {
          div.className = 'warning-item info';
          showNotification(msg, 'info', 2000);
        }
        
        setTimeout(function() {
          if (warningBanner.contains(div)) {
            warningBanner.removeChild(div);
            updateBannerVisibility();
          }
        }, type === 'error' ? 10000 : 5000);
        
        updateBannerVisibility();
      }

      // Unity Configuration with Performance Settings
      var buildUrl = "Build";
      var loaderUrl = buildUrl + "/SKMWebDelight.loader.js";
      
      // WebGL Compatibility Check
      function checkWebGLSupport() {
        const canvas = document.createElement('canvas');
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
        
        if (!gl) {
          showNotification('WebGL is not supported in your browser. Please update your browser or enable WebGL.', 'error', 10000);
          return false;
        }
        
        // Check for specific WebGL extensions and capabilities
        const extensions = gl.getSupportedExtensions();
        const hasCompressedTextures = extensions.includes('WEBGL_compressed_texture_astc') || 
                                    extensions.includes('WEBGL_compressed_texture_s3tc') ||
                                    extensions.includes('WEBGL_compressed_texture_etc');
        
        if (!hasCompressedTextures) {
          showNotification('Compressed textures not supported. Game may load slower.', 'warning', 5000);
        }
        
        // Check WebGL version
        const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
        if (debugInfo) {
          const renderer = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
          console.log('WebGL Renderer:', renderer);
          
          // Check for known problematic renderers
          if (renderer.includes('Intel') || renderer.includes('AMD')) {
            showNotification('Graphics driver compatibility detected. Game may have reduced performance.', 'warning', 5000);
          }
        }
        
        return true;
      }
      
      // Enhanced WebGL error suppression and handling
      function setupWebGLErrorHandling() {
        // Override console.error to catch WebGL errors
        const originalConsoleError = console.error;
        console.error = function(...args) {
          const message = args.join(' ');
          
          // Suppress specific WebGL errors that don't affect functionality
          if (message.includes('INVALID_ENUM: getInternalformatParameter')) {
            // This is a common WebGL extension check that can be safely ignored
            console.warn('WebGL extension check suppressed:', message);
            return;
          }
          
          if (message.includes('UNorm format is not supported')) {
            // Texture format fallback is automatic, just log as info
            console.info('Texture format fallback:', message);
            return;
          }
          
          // Log other errors normally
          originalConsoleError.apply(console, args);
        };
        
        // Override WebGL context methods to prevent INVALID_ENUM errors
        if (window.WebGLRenderingContext) {
          const originalGetParameter = WebGLRenderingContext.prototype.getParameter;
          WebGLRenderingContext.prototype.getParameter = function(parameter) {
            try {
              return originalGetParameter.call(this, parameter);
            } catch (e) {
              if (e.name === 'INVALID_ENUM') {
                // Return safe defaults for unsupported parameters
                switch (parameter) {
                  case this.MAX_TEXTURE_SIZE:
                    return 4096; // Safe default texture size
                  case this.MAX_VIEWPORT_DIMS:
                    return [4096, 4096]; // Safe default viewport
                  case this.MAX_VERTEX_ATTRIBS:
                    return 16; // Safe default vertex attributes
                  default:
                    return 0; // Safe default for unknown parameters
                }
              }
              throw e;
            }
          };
        }
        
        // Override WebGL2 context methods if available
        if (window.WebGL2RenderingContext) {
          const originalGetParameter2 = WebGL2RenderingContext.prototype.getParameter;
          WebGL2RenderingContext.prototype.getParameter = function(parameter) {
            try {
              return originalGetParameter2.call(this, parameter);
            } catch (e) {
              if (e.name === 'INVALID_ENUM') {
                // Return safe defaults for unsupported parameters
                switch (parameter) {
                  case this.MAX_TEXTURE_SIZE:
                    return 4096;
                  case this.MAX_VIEWPORT_DIMS:
                    return [4096, 4096];
                  case this.MAX_VERTEX_ATTRIBS:
                    return 16;
                  default:
                    return 0;
                }
              }
              throw e;
            }
          };
        }
        
        // Override getContext to inject error handling
        const originalGetContext = HTMLCanvasElement.prototype.getContext;
        HTMLCanvasElement.prototype.getContext = function(contextType, contextAttributes) {
          const context = originalGetContext.call(this, contextType, contextAttributes);
          
          if (context && (contextType === 'webgl' || contextType === 'webgl2')) {
            // Override getInternalformatParameter to prevent INVALID_ENUM errors
            if (context.getInternalformatParameter) {
              const originalGetInternalformatParameter = context.getInternalformatParameter;
              context.getInternalformatParameter = function(target, internalformat, pname) {
                try {
                  return originalGetInternalformatParameter.call(this, target, internalformat, pname);
                } catch (e) {
                  if (e.name === 'INVALID_ENUM') {
                    // Return safe defaults for unsupported internal formats
                    switch (pname) {
                      case context.NUM_SAMPLE_COUNTS:
                        return 0;
                      case context.SAMPLES:
                        return [1];
                      case context.INTERNALFORMAT_PREFERRED:
                        return internalformat;
                      default:
                        return null;
                    }
                  }
                  throw e;
                }
              };
            }
            
            // Override getExtension to handle unsupported extensions gracefully
            const originalGetExtension = context.getExtension;
            context.getExtension = function(name) {
              try {
                return originalGetExtension.call(this, name);
              } catch (e) {
                if (e.name === 'INVALID_ENUM') {
                  console.warn('WebGL extension not supported:', name);
                  return null;
                }
                throw e;
              }
            };
            
            // Override compressedTexImage2D to handle unsupported formats
            if (context.compressedTexImage2D) {
              const originalCompressedTexImage2D = context.compressedTexImage2D;
              context.compressedTexImage2D = function(target, level, internalformat, width, height, border, data) {
                try {
                  return originalCompressedTexImage2D.call(this, target, level, internalformat, width, height, border, data);
                } catch (e) {
                  if (e.name === 'INVALID_ENUM' && internalformat) {
                    console.warn('Compressed texture format not supported, falling back to uncompressed:', internalformat);
                    // Fall back to uncompressed RGBA format
                    const fallbackFormat = context.RGBA;
                    const fallbackType = context.UNSIGNED_BYTE;
                    
                    // Create uncompressed texture data
                    const uncompressedData = new Uint8Array(width * height * 4);
                    for (let i = 0; i < uncompressedData.length; i += 4) {
                      uncompressedData[i] = 255;     // R
                      uncompressedData[i + 1] = 255; // G
                      uncompressedData[i + 2] = 255; // B
                      uncompressedData[i + 3] = 255; // A
                    }
                    
                    return context.texImage2D(target, level, fallbackFormat, width, height, border, fallbackFormat, fallbackType, uncompressedData);
                  }
                  throw e;
                }
              };
            }
          }
          
          return context;
        };
        
        // Override console.warn to suppress specific WebGL warnings
        const originalConsoleWarn = console.warn;
        console.warn = function(...args) {
          const message = args.join(' ');
          
          // Suppress specific WebGL warnings that don't affect functionality
          if (message.includes('RGBA Compressed ASTC') || 
              message.includes('UNorm format is not supported') ||
              message.includes('decompressing texture')) {
            console.info('Texture format fallback (suppressed warning):', message);
            return;
          }
          
          // Log other warnings normally
          originalConsoleWarn.apply(console, args);
        };
      }
      
      // Enhanced Unity configuration with WebGL fallbacks
      var config = {
        dataUrl: buildUrl + "/SKMWebDelight.data",
        frameworkUrl: buildUrl + "/SKMWebDelight.framework.js",
        codeUrl: buildUrl + "/SKMWebDelight.wasm",
        streamingAssetsUrl: "StreamingAssets",
        companyName: "Delight",
        productName: "GoldenMM",
        productVersion: "1.0.3",
        showBanner: unityShowBanner,
        // Performance optimizations
        devicePixelRatio: window.devicePixelRatio || 1,
        // Reduce initial memory allocation
        initialMemorySize: 16 * 1024 * 1024, // 16MB initial
        maximumMemorySize: 256 * 1024 * 1024, // 256MB max
        // Enable streaming for large assets
        streamingAssetsUrl: "StreamingAssets",
        // Optimize for mobile
        mobileTemplate: "PROGRESSIVE",
        // Enable compression
        compressionFormat: "BROTLI",
        // WebGL specific optimizations
        webglContextAttributes: {
          alpha: false,
          antialias: false,
          depth: true,
          failIfMajorPerformanceCaveat: false,
          powerPreference: "default",
          premultipliedAlpha: false,
          preserveDrawingBuffer: false,
          stencil: false,
          desynchronized: false
        },
        // Fallback rendering options
        fallbackQuality: "low",
        // Disable problematic features for better compatibility
        disableWebGL2: false,
        // Memory management
        memoryGrowth: true,
        // Asset streaming
        streamingAssetsUrl: "StreamingAssets",
        // Additional WebGL compatibility settings
        webgl2: false, // Force WebGL 1.0 for better compatibility
        // Texture quality fallbacks
        textureQuality: "low",
        // Disable advanced WebGL features
        disableAdvancedFeatures: true,
        // Force software rendering fallback if needed
        forceSoftwareRendering: false
      };

      // Mobile Detection and Setup
      if (/iPhone|iPad|iPod|Android/i.test(navigator.userAgent)) {
        container.className = "unity-container unity-mobile";
        canvas.className = "unity-mobile";
        
        // Additional mobile optimizations
        config.initialMemorySize = 8 * 1024 * 1024; // 8MB for mobile
        config.maximumMemorySize = 128 * 1024 * 1024; // 128MB max for mobile
        
        // Mobile-specific WebGL settings
        config.webglContextAttributes.antialias = false;
        config.webglContextAttributes.powerPreference = "low-power";
        config.fallbackQuality = "low";
      } else {
        canvas.style.width = "960px";
        canvas.style.height = "600px";
      }

      // Fullscreen Button
      fullscreenButton.addEventListener('click', () => {
        if (gameInstance) {
          gameInstance.SetFullscreen(1);
        }
      });

      // Enhanced Unity Loading with Error Recovery and WebGL Compatibility
      var script = document.createElement("script");
      script.src = loaderUrl;
      script.onload = () => {
        // Setup WebGL error handling before Unity loads
        setupWebGLErrorHandling();
        
        // Show WebGL compatibility mode notification
        showNotification('WebGL compatibility mode enabled. Some visual effects may be reduced for better performance.', 'info', 5000);
        
        // Update status to show WebGL compatibility mode
        statusIndicator.innerHTML = '<i class="fas fa-circle"></i> WebGL Compatibility Mode';
        statusIndicator.className = 'status-indicator webgl-compatibility';
        
        // Check WebGL support before loading Unity
        if (!checkWebGLSupport()) {
          showNotification('WebGL compatibility check failed. Please try a different browser.', 'error', 10000);
          statusIndicator.innerHTML = '<i class="fas fa-circle"></i> WebGL Error';
          statusIndicator.className = 'status-indicator error';
          return;
        }
        
        // Start performance monitoring
        const performanceInterval = setInterval(checkPerformance, 1000);
        
        // Enhanced Unity instance creation with error handling
        createUnityInstance(canvas, config, (progress) => {
          updateProgress(progress);
        }).then((unityInstance) => {
          gameInstance = unityInstance;
          clearInterval(performanceInterval);
          
          // Add Unity event listeners for better error handling
          if (unityInstance) {
            // Listen for Unity errors
            unityInstance.on('error', (error) => {
              console.error('Unity Error:', error);
              
              // Handle specific WebGL errors
              if (error.includes('WebGL') || error.includes('INVALID_ENUM')) {
                showNotification('WebGL rendering error. Attempting automatic recovery...', 'warning', 5000);
                
                // Automatic recovery with fallback settings
                setTimeout(() => {
                  showNotification('Switching to compatibility mode...', 'info', 3000);
                  restartWithFallbackSettings();
                }, 3000);
              } else {
                showNotification('Game error occurred. Attempting recovery...', 'error', 8000);
              }
            });
            
            // Listen for Unity warnings
            unityInstance.on('warning', (warning) => {
              console.warn('Unity Warning:', warning);
              
              // Handle texture format warnings
              if (warning.includes('UNorm') || warning.includes('ASTC')) {
                showNotification('Texture compatibility issue detected. Game may have reduced visual quality.', 'warning', 5000);
              } else {
                showNotification('Game warning: ' + warning, 'warning', 5000);
              }
            });
            
            // Listen for Unity ready state
            unityInstance.on('ready', () => {
              console.log('Unity instance ready');
              showNotification('Game engine ready!', 'success', 3000);
            });
          }
          
          showNotification('Welcome to GoldenMM!', 'success');
          
          // Initialize game room system
          initializeGameRooms();
        }).catch((message) => {
          clearInterval(performanceInterval);
          console.error('Unity loading failed:', message);
          
          // Enhanced error categorization
          let errorType = 'unknown';
          let userMessage = 'Failed to load game: ' + message;
          
          if (message.includes('WebGL') || message.includes('INVALID_ENUM')) {
            errorType = 'webgl';
            userMessage = 'WebGL compatibility issue detected. Please try updating your graphics drivers or use a different browser.';
          } else if (message.includes('memory') || message.includes('out of memory')) {
            errorType = 'memory';
            userMessage = 'Insufficient memory to load game. Please close other applications and try again.';
          } else if (message.includes('network') || message.includes('fetch')) {
            errorType = 'network';
            userMessage = 'Network error while loading game files. Please check your internet connection.';
          }
          
          showNotification(userMessage, 'error', 10000);
          statusIndicator.innerHTML = '<i class="fas fa-circle"></i> ' + errorType.charAt(0).toUpperCase() + errorType.slice(1) + ' Error';
          statusIndicator.className = 'status-indicator error';
          
          // Provide specific recovery options based on error type
          setTimeout(() => {
            // Automatic recovery based on error type
            if (errorType === 'webgl') {
              showNotification('WebGL error detected. Switching to compatibility mode...', 'info', 5000);
              setTimeout(() => {
                restartWithFallbackSettings();
              }, 2000);
            } else if (errorType === 'memory') {
              showNotification('Memory error detected. Switching to reduced settings...', 'info', 5000);
              setTimeout(() => {
                restartWithReducedMemory();
              }, 2000);
            } else {
              showNotification('Unknown error detected. Attempting automatic retry...', 'info', 5000);
              setTimeout(() => {
                location.reload();
              }, 3000);
            }
          }, 2000);
        });
      };
      
      // Fallback settings for WebGL compatibility issues
      function restartWithFallbackSettings() {
        showNotification('Restarting with compatibility settings...', 'info', 3000);
        
        // Update config for better compatibility
        config.webglContextAttributes.antialias = false;
        config.webglContextAttributes.depth = false;
        config.fallbackQuality = "low";
        config.initialMemorySize = 8 * 1024 * 1024; // Reduce to 8MB
        
        // Reload with new settings
        setTimeout(() => {
          location.reload();
        }, 2000);
      }
      
      // Reduced memory settings for memory issues
      function restartWithReducedMemory() {
        showNotification('Restarting with reduced memory settings...', 'info', 3000);
        
        // Update config for lower memory usage
        config.initialMemorySize = 4 * 1024 * 1024; // Reduce to 4MB
        config.maximumMemorySize = 64 * 1024 * 1024; // Reduce to 64MB
        
        // Reload with new settings
        setTimeout(() => {
          location.reload();
        }, 2000);
      }
      
      // Handle script loading errors
      script.onerror = () => {
        showNotification('Failed to load game files. Please check your internet connection.', 'error', 10000);
        statusIndicator.innerHTML = '<i class="fas fa-circle"></i> Load Error';
        statusIndicator.className = 'status-indicator error';
      };
      
      document.body.appendChild(script);

      // Close modals when clicking outside
      window.addEventListener('click', (e) => {
        if (e.target === settingsModal) hideModal(settingsModal);
        if (e.target === helpModal) hideModal(helpModal);
      });

      // Keyboard shortcuts
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          if (settingsModal.style.display === 'flex') hideModal(settingsModal);
          if (helpModal.style.display === 'flex') hideModal(helpModal);
        }
      });

      // Page visibility API for better performance
      document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
          // Page is hidden, reduce performance
          if (gameInstance) {
            // Pause Unity if possible
            try {
              gameInstance.SendMessage('GameManager', 'OnPageHidden');
            } catch (e) {
              // Unity not ready yet
            }
          }
        } else {
          // Page is visible, restore performance
          if (gameInstance) {
            try {
              gameInstance.SendMessage('GameManager', 'OnPageVisible');
            } catch (e) {
              // Unity not ready yet
            }
          }
        }
      });

      // Handle page unload gracefully
      window.addEventListener('beforeunload', () => {
        if (gameInstance) {
          try {
            // Clean up Unity resources
            gameInstance.Quit();
          } catch (e) {
            // Unity already unloaded
          }
        }
      });

      // Performance warning for slow devices
      if ('connection' in navigator) {
        const connection = navigator.connection;
        if (connection.effectiveType === 'slow-2g' || connection.effectiveType === '2g') {
          showNotification('Slow connection detected. Game may take longer to load.', 'warning', 8000);
        }
      }
      
      // Gentle performance monitoring instead of aggressive timeouts
      function initializeGentleMonitoring() {
        // Monitor loading progress without forcing timeouts
        const monitorInterval = setInterval(() => {
          if (isGameLoaded) {
            clearInterval(monitorInterval);
            return;
          }
          
          // Only show gentle reminders, not aggressive timeouts
          if (Date.now() - loadStartTime > 45000) { // 45 seconds
            if (!performanceWarningsShown.has('gentle')) {
              performanceWarningsShown.add('gentle');
              showNotification('Game is still loading. This may take a few minutes on slower connections.', 'info', 10000);
            }
          }
        }, 10000); // Check every 10 seconds
      }
      
      // Initialize gentle monitoring instead of aggressive timeout protection
      initializeGentleMonitoring();
    </script>
  </body>
</html>
